/**
 * generateIssuesPdf — Client-side PDF report generator
 * Produces a professional contract-issues report grouped by category.
 *
 * Each issue includes:
 *   - Title & severity
 *   - Why it is flagged (whyConcern)
 *   - Recommended change (suggestedEdits[].proposedText / replacementText)
 *   - Why the change is recommended (suggestedEdits[].value)
 *
 * Uses jsPDF — no server roundtrip required.
 */

import { jsPDF } from 'jspdf';
import type { Issue, ContractMetadata, Severity } from '@/contexts/ContractContext';
import { calculateRiskScore, riskScoreLabel, SEVERITY_ORDER, countBySeverity } from './contractAnalysis';

// ─── Colours (RGB) ───────────────────────────────────────────────────────────

const COLORS: Record<string, [number, number, number]> = {
    white: [255, 255, 255],
    dark: [18, 18, 24],
    muted: [140, 140, 160],
    accent: [96, 165, 250],   // sapphire-ish
    critical: [239, 68, 68],
    high: [249, 115, 22],
    medium: [245, 158, 11],
    low: [96, 165, 250],
    divider: [45, 45, 60],
};

const SEVERITY_LABEL: Record<Severity, string> = {
    critical: 'CRITICAL',
    high: 'HIGH',
    medium: 'MEDIUM',
    low: 'LOW',
};

// ─── Helpers ─────────────────────────────────────────────────────────────────

/** Word-wrap `text` into lines that fit within `maxWidth` at the current font. */
function wrapText(doc: jsPDF, text: string, maxWidth: number): string[] {
    return doc.splitTextToSize(text, maxWidth) as string[];
}

/** Draw a horizontal rule. */
function drawHr(doc: jsPDF, y: number, left: number, right: number, color: [number, number, number] = COLORS.divider) {
    doc.setDrawColor(...color);
    doc.setLineWidth(0.3);
    doc.line(left, y, right, y);
}

/** Ensure there's room on the page; add a new page if not. Returns current Y. */
function ensureSpace(doc: jsPDF, y: number, needed: number, marginTop: number): number {
    const pageH = doc.internal.pageSize.getHeight();
    if (y + needed > pageH - 20) {
        doc.addPage();
        return marginTop;
    }
    return y;
}

/** Draw page number footer on every page. */
function addPageNumbers(doc: jsPDF) {
    const totalPages = doc.getNumberOfPages();
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(...COLORS.muted);
        doc.text(`Page ${i} of ${totalPages}`, pageW / 2, pageH - 10, { align: 'center' });
        doc.text('Generated by Flint — Contract Intelligence', pageW / 2, pageH - 6, { align: 'center' });
    }
}

// ─── Main Generator ──────────────────────────────────────────────────────────

export function generateIssuesPdf(issues: Issue[], metadata?: ContractMetadata): void {
    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    const pageW = doc.internal.pageSize.getWidth();
    const marginL = 18;
    const marginR = pageW - 18;
    const contentW = marginR - marginL;
    const marginTop = 20;
    let y = marginTop;

    // ── Title Page ──────────────────────────────────────────────────────────

    // Background
    doc.setFillColor(...COLORS.dark);
    doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');

    y = 50;
    doc.setFontSize(28);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...COLORS.white);
    doc.text('Contract Issues Report', marginL, y);

    y += 12;
    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...COLORS.accent);
    doc.text(metadata?.title || 'Untitled Contract', marginL, y);

    y += 10;
    doc.setFontSize(10);
    doc.setTextColor(...COLORS.muted);
    const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    doc.text(`Generated: ${dateStr}`, marginL, y);

    if (metadata?.counterparty) {
        y += 6;
        doc.text(`Counterparty: ${metadata.counterparty}`, marginL, y);
    }
    if (metadata?.jurisdiction) {
        y += 6;
        doc.text(`Jurisdiction: ${metadata.jurisdiction}`, marginL, y);
    }

    // ── Summary Box ─────────────────────────────────────────────────────────

    y += 16;
    const riskScore = calculateRiskScore(issues);
    const riskInfo = riskScoreLabel(riskScore);
    const counts = countBySeverity(issues);

    // Box
    doc.setFillColor(30, 30, 42);
    doc.roundedRect(marginL, y, contentW, 36, 3, 3, 'F');

    y += 10;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...COLORS.white);
    doc.text('Executive Summary', marginL + 6, y);

    y += 7;
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...COLORS.muted);
    doc.text(`Total Issues: ${issues.length}    |    Risk Score: ${riskScore}/100 (${riskInfo.label})`, marginL + 6, y);

    y += 7;
    const countLine = `Critical: ${counts.critical}    High: ${counts.high}    Medium: ${counts.medium}    Low: ${counts.low}`;
    doc.text(countLine, marginL + 6, y);

    // ── Issues by Category ──────────────────────────────────────────────────

    // Group issues by category
    const byCategory: Record<string, Issue[]> = {};
    for (const issue of issues) {
        const cat = issue.category || 'General';
        byCategory[cat] = byCategory[cat] || [];
        byCategory[cat].push(issue);
    }

    // Sort categories alphabetically, but put critical-containing ones first
    const categoryOrder = Object.keys(byCategory).sort((a, b) => {
        const aMax = Math.max(...byCategory[a].map(i => SEVERITY_ORDER.indexOf(i.severity)));
        const bMax = Math.max(...byCategory[b].map(i => SEVERITY_ORDER.indexOf(i.severity)));
        // Lower index = more severe (critical=0)
        const aMinIdx = Math.min(...byCategory[a].map(i => SEVERITY_ORDER.indexOf(i.severity)));
        const bMinIdx = Math.min(...byCategory[b].map(i => SEVERITY_ORDER.indexOf(i.severity)));
        if (aMinIdx !== bMinIdx) return aMinIdx - bMinIdx;
        return a.localeCompare(b);
    });

    // Start new page for issues
    doc.addPage();
    doc.setFillColor(...COLORS.dark);
    doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
    y = marginTop;

    for (const category of categoryOrder) {
        const catIssues = byCategory[category];

        // Sort within category by severity
        catIssues.sort((a, b) => SEVERITY_ORDER.indexOf(a.severity) - SEVERITY_ORDER.indexOf(b.severity));

        // Category header — check space
        y = ensureSpace(doc, y, 20, marginTop);
        // Fill background for new pages
        if (y === marginTop) {
            doc.setFillColor(...COLORS.dark);
            doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
        }

        doc.setFontSize(13);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...COLORS.accent);
        doc.text(category, marginL, y);
        y += 2;
        drawHr(doc, y, marginL, marginR, COLORS.accent);
        y += 6;

        doc.setFontSize(9);
        doc.setTextColor(...COLORS.muted);
        doc.text(`${catIssues.length} issue${catIssues.length > 1 ? 's' : ''} in this category`, marginL, y);
        y += 7;

        for (const issue of catIssues) {
            // Estimate space needed for this issue
            const neededEst = 50;
            y = ensureSpace(doc, y, neededEst, marginTop);
            if (y === marginTop) {
                doc.setFillColor(...COLORS.dark);
                doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
            }

            // ── Issue title + severity badge ──
            const sevColor = COLORS[issue.severity] || COLORS.medium;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...COLORS.white);
            doc.text(issue.title, marginL + 2, y);

            // Severity badge
            const badgeText = SEVERITY_LABEL[issue.severity] || 'MEDIUM';
            const badgeW = doc.getTextWidth(badgeText) + 6;
            doc.setFillColor(...sevColor);
            doc.roundedRect(marginR - badgeW - 2, y - 4, badgeW + 2, 6, 1.5, 1.5, 'F');
            doc.setFontSize(7);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...COLORS.white);
            doc.text(badgeText, marginR - badgeW + 1, y);

            y += 7;

            // ── Why it is flagged ──
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...COLORS.accent);
            doc.text('Why This Is Flagged:', marginL + 2, y);
            y += 4;

            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...COLORS.muted);
            const whyLines = wrapText(doc, issue.whyConcern || 'No explanation provided.', contentW - 6);
            for (const line of whyLines) {
                y = ensureSpace(doc, y, 6, marginTop);
                if (y === marginTop) {
                    doc.setFillColor(...COLORS.dark);
                    doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...COLORS.muted);
                }
                doc.text(line, marginL + 4, y);
                y += 4;
            }

            y += 2;

            // ── Recommended Changes ──
            if (issue.suggestedEdits && issue.suggestedEdits.length > 0) {
                for (let ei = 0; ei < issue.suggestedEdits.length; ei++) {
                    const edit = issue.suggestedEdits[ei];

                    y = ensureSpace(doc, y, 16, marginTop);
                    if (y === marginTop) {
                        doc.setFillColor(...COLORS.dark);
                        doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                    }

                    // Recommendation label
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    // Purple-ish for recommendations
                    doc.setTextColor(139, 92, 246);
                    const recLabel = issue.suggestedEdits.length > 1
                        ? `Recommended Change ${ei + 1}:`
                        : 'Recommended Change:';
                    doc.text(recLabel, marginL + 2, y);
                    y += 4;

                    // The proposed/replacement text
                    const changeText = edit.replacementText || edit.proposedText || 'See discussion prompts for guidance.';
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...COLORS.white);
                    doc.setFontSize(8);
                    const changeLines = wrapText(doc, `"${changeText}"`, contentW - 8);
                    for (const line of changeLines) {
                        y = ensureSpace(doc, y, 6, marginTop);
                        if (y === marginTop) {
                            doc.setFillColor(...COLORS.dark);
                            doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                            doc.setFontSize(8);
                            doc.setFont('helvetica', 'normal');
                            doc.setTextColor(...COLORS.white);
                        }
                        doc.text(line, marginL + 4, y);
                        y += 4;
                    }

                    // Why recommended
                    if (edit.value) {
                        y += 1;
                        y = ensureSpace(doc, y, 10, marginTop);
                        if (y === marginTop) {
                            doc.setFillColor(...COLORS.dark);
                            doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                        }
                        doc.setFontSize(8);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(52, 211, 153); // emerald
                        doc.text('Why Recommended:', marginL + 2, y);
                        y += 4;

                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(...COLORS.muted);
                        const whyRecLines = wrapText(doc, edit.value, contentW - 8);
                        for (const line of whyRecLines) {
                            y = ensureSpace(doc, y, 6, marginTop);
                            if (y === marginTop) {
                                doc.setFillColor(...COLORS.dark);
                                doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                                doc.setFontSize(8);
                                doc.setFont('helvetica', 'normal');
                                doc.setTextColor(...COLORS.muted);
                            }
                            doc.text(line, marginL + 4, y);
                            y += 4;
                        }
                    }

                    // Tradeoffs
                    if (edit.tradeoffs) {
                        y += 1;
                        y = ensureSpace(doc, y, 10, marginTop);
                        if (y === marginTop) {
                            doc.setFillColor(...COLORS.dark);
                            doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                        }
                        doc.setFontSize(8);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(251, 191, 36); // amber
                        doc.text('Tradeoffs:', marginL + 2, y);
                        y += 4;

                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(...COLORS.muted);
                        const tradeLines = wrapText(doc, edit.tradeoffs, contentW - 8);
                        for (const line of tradeLines) {
                            y = ensureSpace(doc, y, 6, marginTop);
                            if (y === marginTop) {
                                doc.setFillColor(...COLORS.dark);
                                doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
                                doc.setFontSize(8);
                                doc.setFont('helvetica', 'normal');
                                doc.setTextColor(...COLORS.muted);
                            }
                            doc.text(line, marginL + 4, y);
                            y += 4;
                        }
                    }

                    y += 2;
                }
            } else {
                // No suggested edits
                doc.setFontSize(8);
                doc.setFont('helvetica', 'italic');
                doc.setTextColor(...COLORS.muted);
                doc.text('No specific edit recommended — discuss with counsel.', marginL + 4, y);
                y += 5;
            }

            // Divider between issues
            y += 2;
            y = ensureSpace(doc, y, 4, marginTop);
            if (y === marginTop) {
                doc.setFillColor(...COLORS.dark);
                doc.rect(0, 0, pageW, doc.internal.pageSize.getHeight(), 'F');
            }
            drawHr(doc, y, marginL + 4, marginR - 4);
            y += 6;
        }

        y += 4; // Extra spacing between categories
    }

    // ── Page numbers & footer ───────────────────────────────────────────────

    addPageNumbers(doc);

    // ── Download ────────────────────────────────────────────────────────────

    const filename = metadata?.title
        ? `${metadata.title.replace(/[^a-zA-Z0-9 ]/g, '').replace(/\s+/g, '_')}_Issues_Report.pdf`
        : 'Contract_Issues_Report.pdf';

    doc.save(filename);
}
